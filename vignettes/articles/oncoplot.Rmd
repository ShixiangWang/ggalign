---
title: "Oncoplot"
output: rmarkdown::html_vignette
params:
  mode: !r if (endsWith(as.character(desc::desc_get_version()), '9000')) 'devel' else 'release'
  release: "https://yunuuuu.github.io/ggalign"
  devel: "https://yunuuuu.github.io/ggalign/dev"
vignette: >
  %\VignetteIndexEntry{Oncoplot}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

```{r echo=FALSE}
mode <- params$mode
url <- params[[mode]]
```

# ggoncoplot
The `ggoncoplot()` function generates `oncoPrint` visualizations that display
genetic alterations in a matrix format. This function is especially useful for
visualizing complex genomic data, such as mutations, copy number variations, and
other genomic alterations in cancer research. 

# Input data
The input should be a character matrix which encodes the alterations, you can use
string of `r ggalign:::oxford_and(c(";", ":", ",", "|"))` to separate multiple
alterations. All empty string will be converted to `NA` value.
```{r}
mat <- read.table(
    textConnection(
        "s1,s2,s3
         g1,snv;indel,snv,indel
         g2,,snv;indel,snv
         g3,snv,,indel;snv"
    ),
    row.names = 1, header = TRUE, sep = ",", stringsAsFactors = FALSE
)
mat
```

A simple oncoprint can be generated as follows:
```{r}
library(ggalign)
ggoncoplot(mat)
```

# oncoPrint main plot
By default, all alterations are represented with tiles of equal width and
height, which may lead to overlapping (we'll introduce more well way to deal
with overlapping). You can control the `width` and `height`
of the tiles using the `map_width` and `map_height` arguments: 
```{r}
ggoncoplot(mat, map_width = c(snv = 0.5), map_height = c(indel = 0.9))
```

By default, `ggplot2` translates `NA` values. To prevent this, you can turn off
the translation using `na.translate = FALSE`: 
```{r}
ggoncoplot(mat) +
    scale_fill_brewer(palette = "Dark2", na.translate = FALSE)
```

By default, the function will reorder the columns and rows based on the
frequency or characteristics of the alterations. You can turn this off by
setting `reorder_row = FALSE` and `reorder_column = FALSE`. In this case, you
can use 
[layout-customize](`r sprintf("%s/articles/layout-customize.html", url)`) to
define the layout design.
```{r}
ggoncoplot(mat, reorder_row = FALSE, reorder_column = FALSE) +
    scale_fill_brewer(palette = "Dark2", na.translate = FALSE)
```

# plot_data()
`ggoncoplot()` is built on `ggheatmap()` with a default `plot_data()` 
[plot option](`r sprintf("%s/articles/plot-options.html", url)`), which splits
the nested alterations and unnests the column, similar to the following
function (See `ggheatmap()` ggplot2 specification section for the input data of
`plot_data()`):
```{r eval=rlang::is_installed("tidyr")}
pdata <- function(data) {
    tidyr::separate_longer_delim(data,
        cols = value,
        delim = stringr::regex("\\s*[;:,|]\\s*")
    )
}
# Note: `ggoncoplot()` will automatically convert any empty strings to `NA`
#        before pass it to `ggheatmap`.
ggheatmap(mat) -
    plot_data(pdata) +
    scale_fill_brewer(palette = "Dark2", na.translate = FALSE)
```

By default, the `plot_data()` is inherited from the parent layout if the data of
the plot is inherited from the layout. You can apply the parent `plot_data()`
first and then apply another transformation by setting `inherit = TRUE`. 

Since `ggoncoplot()` is just a `ggheatmap()`, you can utilize all operations
introduced in 
[heatmap-layout](`r sprintf("%s/articles/heatmap-layout.html", url)`).

```{r}
ggoncoplot(mat, map_width = c(snv = 0.5), map_height = c(indel = 0.9)) +
    anno_top(size = 0.2) +
    ggalign() +
    # by setting `inherti = TRUE`, we apply the parent layout `plot_data()`
    # firstly, then remove `NA` value
    plot_data(~ subset(.x, !is.na(value)), inherit = TRUE) +
    geom_bar(aes(.x, after_stat(count), fill = value)) +
    # note: `ggoncoplot()` use `geom_tile()` to draw the oncoPrint,
    # the guide is different from `geom_bar()`, though both looks
    # like the same, we remove the guide of `geom_bar()` plot
    guides(fill = "none") &
    scale_fill_brewer(palette = "Dark2", na.translate = FALSE)
```

# maftools object
The `ggoncoplot()` function supports `MAF` objects from the `maftools` package
using the `fortify_matrix.MAF()` method. It includes options to control data
generation for `ggoncoplot()`/`ggheatmap()`, such as drawing the top `n_top`
genes.
```{r echo=FALSE}
can_read_maf <- rlang::is_installed("maftools") &&
    rlang::is_installed("R.utils")
```
```{r eval=can_read_maf}
# load data from `maftools`
laml.maf <- system.file("extdata", "tcga_laml.maf.gz", package = "maftools")
# clinical information containing survival information and histology. This is optional
laml.clin <- system.file("extdata", "tcga_laml_annot.tsv", package = "maftools")
laml <- maftools::read.maf(
    maf = laml.maf,
    clinicalData = laml.clin,
    verbose = FALSE
)
# Visualizing the Top 20 Genes
ggoncoplot(laml, n_top = 20) +
    scale_fill_brewer(palette = "Dark2", na.translate = FALSE) +
    theme_no_axes("x")
```

By default, samples without alterations in the selected genes are removed. To
include all samples, set `remove_empty_samples = FALSE`: 
```{r eval=can_read_maf}
align_plots(
    ggoncoplot(laml, n_top = 20L, remove_empty_samples = FALSE) +
        scale_fill_brewer(palette = "Dark2", na.translate = FALSE) +
        theme_no_axes("x") +
        ggtitle("Keep empty samples"),
    ggoncoplot(laml, n_top = 20L, remove_empty_samples = TRUE) +
        scale_fill_brewer(palette = "Dark2", na.translate = FALSE) +
        theme_no_axes("x") +
        ggtitle("Remove empty samples"),
    ncol = 1L,
    guides = "tlbr"
)
```

When multiple alterations occur in the same sample and gene, they are combined
into a single value, "Multi_Hit", by default. To visualize these alterations
separately, you can set `collapse_vars = FALSE`. However, doing so can lead to
overlapping alterations within the same cell, making the visualization cluttered
and hard to interpret.

In such cases, disabling the default filling and defining a custom heatmap layer
with `geom_subtile()` is more effective. This function subdivides each cell into
smaller rectangles, allowing the distinct alterations to be clearly displayed.
```{r eval=can_read_maf}
ggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +
    geom_subtile(aes(fill = value), direction = "vertical") +
    scale_fill_brewer(palette = "Dark2", na.translate = FALSE) +
    theme_no_axes("x")
```

To focus only on cells with multiple alterations, filter the data before
applying `geom_subtile()`:
```{r eval=can_read_maf && rlang::is_installed("dplyr")}
ggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +
    plot_data(function(data) {
        dplyr::filter(data, dplyr::n() > 1L, .by = c(".x", ".y"))
        # we apply the parent layout `plot_data()` first: `inherit = TRUE`
    }, inherit = TRUE) +
    geom_subtile(aes(fill = value), direction = "vertical") +
    scale_fill_brewer(palette = "Dark2", na.translate = FALSE) +
    theme_no_axes("x")
```

If you're aiming for a strategy similar to that of `ComplexHeatmap`, consider
using `geom_draw()`. Although `geom_subtile()` often suffices for most
scenarios, `geom_draw()` provides greater flexibility for complex customization. 

Key Features of `geom_draw()`:

 - Custom Drawing Logic: Accepts a `draw` aesthetic, allowing each cell to be
 rendered as a specific graphical object (`grob`). 
 - Manual Scaling: Requires `scale_draw_manual()` to map `draw` values to
 corresponding drawing functions. Functions mapped through `scale_draw_manual()`
 can utilize any number of ggplot2 aesthetics and output custom graphical
 objects (`grob`).


```{r}
library(grid)
ggplot(data.frame(value = letters[seq_len(5)], y = seq_len(5))) +
    geom_draw(aes(x = 1, y = y, draw = value, fill = value)) +
    scale_draw_manual(values = list(
        a = function(x, y, width, height, fill) {
            rectGrob(x, y,
                width = width, height = height,
                gp = gpar(fill = fill),
                default.units = "native"
            )
        },
        b = function(x, y, width, height, fill) {
            rectGrob(x, y,
                width = width, height = height,
                gp = gpar(fill = fill),
                default.units = "native"
            )
        },
        c = function(x, y, width, height, fill) {
            rectGrob(x, y,
                width = width, height = height,
                gp = gpar(fill = fill),
                default.units = "native"
            )
        },
        d = function(x, y, width, height, shape) {
            gList(
                pointsGrob(x, y, pch = shape),
                # To ensure the rectangle color is shown in the legends, you
                # must explicitly provide a color argument and include it in the
                # `gpar()` of the graphical object
                rectGrob(x, y, width, height,
                    gp = gpar(col = "black", fill = NA)
                )
            )
        },
        e = function(xmin, xmax, ymin, ymax) {
            segmentsGrob(
                xmin,
                ymin,
                xmax,
                ymax,
                gp = gpar(lwd = 2)
            )
        }
    )) +
    scale_fill_brewer(palette = "Dark2") +
    theme_void()
```

# ggalign attributes
Except for the data used for the main plot, `fortify_matrix.MAF()` also attaches
several useful attributes. For more details, refer to the section on 
`ggalign attributes` in the `fortify_matrix.MAF()` documentation. You can
extract these attributes using the `ggalign_attr()` function.

Below is an example of how to extract the sample summary data (e.g., TMB) using
`ggalign_attr()` and add it to the top annotation of an oncoplot:
```{r eval=can_read_maf}
ggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +
    geom_subtile(aes(fill = value), direction = "vertical") +
    theme_no_axes("x") +
    anno_top(size = 0.2) +
    ggalign(data = function(data) {
        data <- ggalign_attr(data, "sample_summary")
        as.matrix(data[2:(ncol(data) - 1L)])
    }) +
    geom_bar(aes(.x, value, fill = .column_names),
        stat = "identity"
    ) +
    ylab("TMB") &
    scale_fill_brewer(palette = "Dark2", na.translate = FALSE)
```

Here's how you might visualize the number of samples for each gene:
```{r eval=can_read_maf}
ggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +
    geom_subtile(aes(fill = value), direction = "vertical") +
    theme_no_axes("x") +
    anno_right(size = 0.2) +
    ggalign(data = function(data) {
        data <- ggalign_attr(data, "gene_summary")
        as.matrix(data[2:8])
    }) +
    geom_bar(aes(value, fill = .column_names),
        stat = "identity",
        orientation = "y"
    ) +
    xlab("No. of samples") &
    scale_fill_brewer(palette = "Dark2", na.translate = FALSE)
```

To visualize the Transition/Transversion (Ti/Tv) ratio, you can extract the
fraction contribution:
```{r eval=can_read_maf}
ggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +
    geom_subtile(aes(fill = value), direction = "vertical") +
    theme_no_axes("x") +
    scale_fill_brewer(palette = "Dark2", na.translate = FALSE) +
    anno_bottom(size = 0.2) +
    ggalign(data = function(data) {
        data <- ggalign_attr(data, "titv")$fraction.contribution
        as.matrix(data[2:7])
    }) +
    geom_bar(aes(y = value, fill = .column_names), stat = "identity") +
    ylab("Ti/Tv") +
    scale_fill_brewer(palette = "Set2")
```

We can combine all of these elements as follows:
```{r eval=can_read_maf}
ggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +
    geom_subtile(aes(fill = value), direction = "vertical") +
    theme_no_axes("x") +
    # since legends from geom_tile (oncoPrint body) and `geom_bar`
    # is different, though both looks like the same, the internal
    # won't merge the legends. we remove the legends of oncoPrint body
    guides(fill = "none") +
    anno_top(size = 0.2) +
    ggalign(data = function(data) {
        data <- ggalign_attr(data, "sample_summary")
        as.matrix(data[2:(ncol(data) - 1L)])
    }) +
    geom_bar(aes(.x, value, fill = .column_names),
        stat = "identity"
    ) +
    ylab("TMB") +
    anno_right(size = 0.2) +
    ggalign(data = function(data) {
        data <- ggalign_attr(data, "gene_summary")
        as.matrix(data[2:8])
    }) +
    geom_bar(aes(value, fill = .column_names),
        stat = "identity",
        orientation = "y"
    ) +
    xlab("No. of samples") -
    # we apply the scale mapping to the top and right annotation: `position = "tr"`
    # and the main plot: `main = TRUE`
    with_quad(
        scale_fill_brewer("Mutations",
            palette = "Dark2", na.translate = FALSE
        ),
        position = "tr",
        main = TRUE
    ) +
    anno_bottom(size = 0.2) +
    ggalign(data = function(data) {
        data <- ggalign_attr(data, "titv")$fraction.contribution
        as.matrix(data[2:7])
    }) +
    geom_bar(aes(y = value, fill = .column_names), stat = "identity") +
    ylab("Ti/Tv") +
    scale_fill_brewer("Ti/Tv", palette = "Set2")
```

# Session information
```{r}
sessionInfo()
```
