---
title: "ComplexHeatmap: single-heatmap"
output: rmarkdown::html_vignette
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

In this thread, We'll use `ggalign` to draw all the heatmap in
<https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html>

```{r setup}
library(ggalign)
```

```{r}
set.seed(123)
nr1 <- 4
nr2 <- 8
nr3 <- 6
nr <- nr1 + nr2 + nr3
nc1 <- 6
nc2 <- 8
nc3 <- 10
nc <- nc1 + nc2 + nc3
mat <- cbind(
    rbind(
        matrix(rnorm(nr1 * nc1, mean = 1, sd = 0.5), nrow = nr1),
        matrix(rnorm(nr2 * nc1, mean = 0, sd = 0.5), nrow = nr2),
        matrix(rnorm(nr3 * nc1, mean = 0, sd = 0.5), nrow = nr3)
    ),
    rbind(
        matrix(rnorm(nr1 * nc2, mean = 0, sd = 0.5), nrow = nr1),
        matrix(rnorm(nr2 * nc2, mean = 1, sd = 0.5), nrow = nr2),
        matrix(rnorm(nr3 * nc2, mean = 0, sd = 0.5), nrow = nr3)
    ),
    rbind(
        matrix(rnorm(nr1 * nc3, mean = 0.5, sd = 0.5), nrow = nr1),
        matrix(rnorm(nr2 * nc3, mean = 0.5, sd = 0.5), nrow = nr2),
        matrix(rnorm(nr3 * nc3, mean = 1, sd = 0.5), nrow = nr3)
    )
)
mat <- mat[sample(nr, nr), sample(nc, nc)]
rownames(mat) <- paste0("row", seq_len(nr))
colnames(mat) <- paste0("column", seq_len(nc))
```

# Colors
Because the `ComplexHeatmap` will reorder the dendrogram by default, but
`align_dendro` won't change the tree layout. In following codes, we hypothesized
that the arguments `row_dend_reorder` and `column_dend_reorder` of
`ComplexHeatmap::Heatmap` is `FALSE`.  

It is important to note that `ggalign` considers the left-bottom as the starting
point, while `ComplexHeatmap` considers the left-top as the starting point. 

The `scale_fill_*` function in ggplot2 makes it easy to modify colors.

```{r}
dim(mat)
ggheatmap(mat) +
    scale_fill_gradient2(low = "#2600D1FF", high = "#EE3F3FFF") +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
# ComplexHeatmap::Heatmap(mat,
#   row_dend_reorder = FALSE,
#   column_dend_reorder = FALSE
# )
```

```{r}
ggheatmap(mat) +
    scale_fill_gradient2(low = "green", high = "red") +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
```

`oob` argument in the `scale_fill_*` function can be used to deal with the
outliers.

```{r}
mat2 <- mat
mat2[1, 1] <- 100000
ggheatmap(mat2) +
    scale_fill_gradient2(
        low = "green", high = "red",
        limits = c(-2, 2),
        oob = scales::squish
    ) +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
```

We can use `align_plots()` to arrange them.
```{r fig.dim = c(10, 10)}
h1 <- ggheatmap(mat) +
    scale_fill_gradient2(name = "mat", low = "green", high = "red") +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())

h2 <- ggheatmap(mat / 4) +
    scale_fill_gradient2(
        name = "mat/4", limits = c(-2, 2L),
        oob = scales::squish,
        low = "green", high = "red"
    ) +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())

h3 <- ggheatmap(abs(mat)) +
    scale_fill_gradient2(name = "abs(mat)", low = "green", high = "red") +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
align_plots(h1, h2, h3, ncol = 2L)
```

```{r}
ggheatmap(mat) +
    scale_fill_gradientn(colors = rev(rainbow(10))) +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
```

For character matrix, you can use ggplot2 discrete filling scales.
```{r}
discrete_mat <- matrix(sample(1:4, 100, replace = TRUE), 10, 10)
colors <- structure(1:4, names = c("1", "2", "3", "4")) # black, red, green, blue
ggheatmap(discrete_mat, aes(fill = factor(value))) +
    scale_fill_manual(values = colors) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
```

```{r}
discrete_mat <- matrix(sample(letters[1:4], 100, replace = TRUE), 10, 10)
colors <- structure(1:4, names = letters[1:4])
ggheatmap(discrete_mat) +
    scale_fill_manual(values = colors)
```

```{r}
mat_with_na <- mat
na_index <- sample(c(TRUE, FALSE),
    nrow(mat) * ncol(mat),
    replace = TRUE, prob = c(1, 9)
)
mat_with_na[na_index] <- NA
ggheatmap(mat_with_na) +
    scale_fill_gradient2(
        low = "#2600D1FF",
        high = "#EE3F3FFF",
        na.value = "black"
    ) +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
```

We won't compare the LAB and RGB space. If you want to convert color between
different color space, try to use [farver](https://farver.data-imaginist.com/)
pacakge.

In ggplot2, you can use `panel.border` argument in `theme()` function to control
the Heatmap body border.
```{r}
ggheatmap(mat) +
    scale_fill_gradient2(low = "#2600D1FF", high = "#EE3F3FFF") +
    theme(
        axis.text.x = element_text(angle = -60, hjust = 0),
        panel.border = element_rect(linetype = "dashed", fill = NA)
    ) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
```

You can use `color` aesthetic to specify the cell border color and
`linewidth` aesthetic to specify the border width.
```{r}
ggheatmap(mat, color = "white") +
    scale_fill_gradient2(low = "#2600D1FF", high = "#EE3F3FFF") +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
```

You can use `filling` argument to turn off the heatmap cell filling.
```{r}
ggheatmap(mat, filling = FALSE) +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(15, "mm")) +
    align_dendro() +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
```

# Titles
We can use `patch_titles()` to add titles around each border of the plot. You
can use `theme()` to control the text appearance. 
```{r}
ggheatmap(mat) +
    scale_fill_gradient2(low = "#2600D1FF", high = "#EE3F3FFF") +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(20, "mm")) +
    align_dendro() +
    patch_titles(right = "I am a row title") +
    theme(plot.patch_title.right = element_text(face = "bold", size = 16)) +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    patch_titles(top = "I am a column title") +
    theme(plot.patch_title.top = element_text(face = "bold", size = 16)) +
    hmanno(NULL) &
    theme(plot.margin = margin())
```

# Clustering
## Distance methods
```{r}
ggheatmap(mat) +
    scale_fill_gradient2(low = "#2600D1FF", high = "#EE3F3FFF") +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(20, "mm")) +
    align_dendro(distance = "pearson") +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    patch_titles(top = "pre-defined distance method (1 - pearson)") +
    theme(plot.patch_title.top = element_text(face = "bold", size = 16)) +
    hmanno(NULL) &
    theme(plot.margin = margin())
# ComplexHeatmap::Heatmap(mat,
#   name = "mat", clustering_distance_rows = "pearson",
#   column_title = "pre-defined distance method (1 - pearson)",
#   row_dend_reorder = FALSE,
#   column_dend_reorder = FALSE
# )
```

```{r}
ggheatmap(mat) +
    scale_fill_gradient2(low = "#2600D1FF", high = "#EE3F3FFF") +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(20, "mm")) +
    align_dendro(distance = dist) +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    patch_titles(top = "a function that calculates distance matrix") +
    theme(plot.patch_title.top = element_text(face = "bold", size = 16)) +
    hmanno(NULL) &
    theme(plot.margin = margin())
# ComplexHeatmap::Heatmap(mat,
#     name = "mat", clustering_distance_rows = function(m) dist(m),
#     column_title = "a function that calculates distance matrix",
#     row_dend_reorder = FALSE,
#     column_dend_reorder = FALSE
# )
```

## Clustering methods
Method to perform hierarchical clustering can be specified by `method` argument,
Possible methods are those supported in `hclust()` function. 
```{r}
ggheatmap(mat) +
    scale_fill_gradient2(low = "#2600D1FF", high = "#EE3F3FFF") +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(20, "mm")) +
    align_dendro(method = "single") +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
# ComplexHeatmap::Heatmap(mat,
#     name = "mat",
#     clustering_method_rows = "single",
#     row_dend_reorder = FALSE,
#     column_dend_reorder = FALSE
# )
```

Use `distance = NULL` if you don't want to calculate the distance.
```{r}
ggheatmap(mat) +
    scale_fill_gradient2(low = "#2600D1FF", high = "#EE3F3FFF") +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(20, "mm")) +
    align_dendro(distance = NULL, method = cluster::diana) +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro(distance = NULL, method = cluster::agnes) +
    hmanno(NULL) &
    theme(plot.margin = margin())
```

## Render dendrograms
It's easy for `ggalign` to color the branches by setting the color mapping,
since `ggalign` will add the `cutree()` results into the underlying data.
```{r}
ggheatmap(mat) +
    scale_fill_gradient2(low = "#2600D1FF", high = "#EE3F3FFF") +
    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
    hmanno("r", size = unit(20, "mm")) +
    align_dendro(aes(color = branch), k = 2L) +
    hmanno("t", size = unit(15, "mm")) +
    align_dendro() +
    hmanno(NULL) &
    theme(plot.margin = margin())
```

# Session information
```{r}
sessionInfo()
```
