---
title: "Heatmap Layout"
output: 
  bookdown::html_document2:
    base_format: rmarkdown::html_vignette
    number_sections: no
    fig_caption: yes
    fig_width: 7
    fig_height: 5
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Heatmap Layout}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
pkgdown:
  as_is: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The `heatmap_layout()`/`ggheatmap()` function provides a powerful way to create
customizable heatmaps in R using `ggplot2`. This vignette will guide you through
its usage.

# input data
The data input can be a numeric or character vector, a data frame, and any other
data which can be converted into a matrix by `fortify_matrix()`.

```{r setup_data}
set.seed(123)
small_mat <- matrix(rnorm(81), nrow = 9)
rownames(small_mat) <- paste0("row", seq_len(nrow(small_mat)))
colnames(small_mat) <- paste0("column", seq_len(ncol(small_mat)))
```

```{r matrix}
library(ggalign)
ggheatmap(small_mat)
```

# heatmap body
For `ggplot2` usage, the matrix input will be converted into a long formated
data frame when drawing. The default mapping will use `aes(.data$.x, .data$.y)`,
but can be controlled using `mapping` argument. The data in the underlying
ggplot object contains following columns:

  - `.xpanel` and `.ypanel`: the column and row panel

  - `.x` and `.y`: the `x` and `y` coordinates

  - `.row_names` and `.column_names`: A factor of the row and column names of
    the original matrix (only applicable when names exist).

  - `.row_index` and `.column_index`: the row and column index of the original
    matrix.

  - `value`: the actual matrix value.

You can treat the `ggheatmap()`/`heatmap_layout()` object as a standard
`ggplot2` object with default mapping and data. This means you can add `ggplot2`
layers or elements just like in any `ggplot` object.
```{r}
ggheatmap(small_mat) + geom_point() + scale_fill_viridis_c()
```

By default, `ggheatmap()`/`heatmap_layout()` adds a heatmap layer. If the matrix
has more than 20,000 cells (`nrow * ncol > 20000`), it uses `geom_raster()` for
performance efficiency; for smaller matrices, `geom_tile()` is used. You can
explicitly choose the layer by providing a single string (`"raster"` or
`"tile"`) in the `filling` argument.
```{r}
ggheatmap(small_mat, filling = "raster")
```

```{r}
ggheatmap(small_mat, filling = "tile")
```

If you set `filling = NULL`, a blank heatmap will be drawn, allowing for
customized filling geoms. In this way, you must set `fill` mapping manually.
```{r}
ggheatmap(small_mat, filling = NULL) +
  geom_tile(aes(fill = value), color = "black", width = 0.9, height = 0.9)
```

A heatmap pie charts:
```{r}
set.seed(123)
ggheatmap(matrix(runif(360L), nrow = 20L), filling = NULL) +
  geom_pie(aes(angle = value * 360, fill = value))
```

If you want to more complex pie charts, try `ggforce::geom_arc_bar()` instead.

You can use external packages like
[ggrastr](https://github.com/VPetukhov/ggrastr) or
[ggfx](https://ggfx.data-imaginist.com/reference/with_raster.html) to rasterize
the heatmap body. Additionally,
[ggfx](https://ggfx.data-imaginist.com/reference/with_raster.html) offers many
image filters that can be applied to ggplot2 layers.
```{r eval=rlang::is_installed("ragg")}
ggheatmap(small_mat, filling = FALSE) +
  ggrastr::rasterise(geom_tile(aes(fill = value)), dev = "ragg")
```

You can rasterize all plots in the layout directly with `ggrastr::rasterise()`.
This method works for both `ggheatmap()`/`quad_layout()` and `ggstack()`
objects.
```{r eval=rlang::is_installed("ragg")}
ggrastr::rasterise(ggheatmap(small_mat), dev = "ragg")
```

# heatmap annotations
A heatmap typically has two observation axes (rows and columns), which can be
reordered or supplemented with additional information. In `ggheatmap()`,
annotations are handled by a `stack_layout()` object, specifically
`stack_align()`, which aligns the observations. This object can hold multiple
plots and can be positioned at the top, left, bottom, or right of the heatmap. 

Note that `ggalign` use the concept of `"number of observations"` in the
[vctrs](https://vctrs.r-lib.org/reference/vec_size.html) package. When aligning
the observations, you must ensure the number of observations is equal. For
column annotations, the layout matrix will be transposed before use. This is
necessary because column annotations use heatmap columns as observations, but we
need rows.

By default, `heatmap_layout()`/`ggheatmap()` do not initialize an active
context, which means that all additions are directed within the heatmap body.
You can use `quad_anno()` to set the active context, directing all subsequent
additions to the specified annotation position. To remove the active context and
redirect additions back to the heatmap body, you can use `quad_active()`. The
`quad_anno()` function has the following aliases: 
  - `anno_top`: A special case of `quad_anno` with `position = "top"`.
  - `anno_left`: A special case of `quad_anno` with `position = "left"`.
  - `anno_bottom`: A special case of `quad_anno` with `position = "bottom"`.
  - `anno_right`: A special case of `quad_anno` with `position = "right"`.

We also provide `quad_switch()`/`hmanno()` which integrates `quad_active()` and
`quad_anno()` into one function for ease of use. Feel free to use any of these
functions to streamline your annotation process.

You may wonder about the prefix `quad_`. The `ggheatmap()` function is a
specialized version of `quad_layout()`, designed to simplify the creation of
heatmap plots by integrating essential elements for a standard heatmap layout.
Both `quad_anno()` and `quad_active()` are functions designed for
`quad_layout()`. 

The annotations allows for custom layout adjustments and the addition of various
plot types. In the following example, `align_kmeans()` is used to group the
columns into three panels. It doesn't matter if this is added to the top or
bottom since it won't add a plot area: 

```{r}
ggheatmap(small_mat) +
  # we set the active context to the top annotation
  anno_top() +
  # we split the observations into 3 groups by kmeans
  align_kmeans(3L)
```

We can add any `align_*()` function to the annotation. For more details on
`align_*()` functions, refer to `vignette("layout-customize")` and
`vignette("layout-plot")`.

```{r}
ggheatmap(small_mat) +
  # in the heatmap body, we set the axis text theme
  theme(axis.text.x = element_text(angle = -60, hjust = 0)) +
  # we set the active context to the right annotation
  anno_right() +
  # in the right annotation, we add a dendrogram
  align_dendro(k = 3L) +
  # in the dendrogram, we add a point layer
  geom_point(aes(color = factor(branch)))
```

In this example:

 - `anno_right()` change the active context to the right of the heatmap.
 - `align_dendro(k = 3L)` adds a dendrogram to this right-side annotation
 context and sets itself as the active plot in the annotation stack. 
 - `geom_point(aes(color = factor(branch)))` is then added to this active plot
 within the annotation stack, here, it means the `align_dendro()` plot.

# Plot Size
## Heatmap Body Size
You can specify the relative sizes of the heatmap body using the `width` and
`height` arguments in the `ggheatmap()` function.
```{r}
ggheatmap(small_mat, height = 2) +
  scale_fill_viridis_c() +
  anno_top() +
  align_dendro()
```

Alternatively, the `quad_active()` function allows you to control the heatmap
body sizes. 
```{r}
ggheatmap(small_mat) +
  quad_active(height = 2) +
  scale_fill_viridis_c() +
  anno_top() +
  align_dendro()
```

## Annotation Stack Size
The `quad_anno()` function allows you to control the total annotation stack
size. The `size` argument controls the relative width (for left and right
annotations) or height (for top and bottom annotations) of the whole annotation
stack. 

```{r}
ggheatmap(small_mat) +
  scale_fill_viridis_c() +
  anno_top(size = 1) +
  align_dendro()
```

You can also specify it as an absolute size using `unit()`:
```{r}
ggheatmap(small_mat) +
  scale_fill_viridis_c() +
  anno_top(size = unit(30, "mm")) +
  align_dendro()
```

## Single Plot Size
All `align_*()`/`ggfree()` functions that add plots in the annotation stack have
a `size` argument to control the relative `width` (for left and right
annotations) or `height` (for top and bottom annotations) of the single plot in
the annotation stack.
```{r}
ggheatmap(small_mat) +
  scale_fill_viridis_c() +
  anno_left(size = 0.2) +
  ggalign(data = rowSums, aes(x = value), size = unit(10, "mm")) +
  geom_bar(
    aes(y = .y, fill = factor(.y)),
    stat = "identity", orientation = "y"
  ) +
  scale_fill_brewer(palette = "Set1", guide = "none")
```

# Operators
## Addition operator
> `+`: adds elements to the active plot in the active layout.

The `+` operator is straightforward and should be used as needed. In
`ggheatmap()`/`quad_layout()`, four nested layouts are available for
annotations: `top`, `left`, `bottom`, and `right`. If no active annotation is
set, `ggheatmap()`/`quad_layout()` treat itself as the active layout. Since
there is only one main plot in the `ggheatmap()`/`quad_layout()`, the main plot
is always treated as the active plot in this context.
```{r}
# Initialize the heatmap; by default, no active annotation will be set.
# The active layout is the heatmap layout, and the active plot in the layout is
# the main plot.
ggheatmap(small_mat) +
  # Add elements to the main plot
  scale_fill_viridis_c() +
  # Change the active layout to the left annotation
  anno_left(size = 0.2) +
  # Add a dendrogram in the left annotation
  align_dendro() +
  # Change the active layout to the right annotation
  anno_right(size = 0.2) +
  # Add a dendrogram in the right annotation
  align_dendro()
```

## logical AND operator
> `&`: applies elements to all plots in the layout.

The `&` operator works similarly to `patchwork`, applying an element across all
plots in a layout. If the element is a `theme()`, it modifies the layout's
theme, which includes settings for guides, titles, subtitles, captions, margins,
panel borders, and backgrounds. This `theme` is provided as an input argument in
functions like `ggheatmap()`/`quad_layout()`. Since `&` has lower precedence
than `+`, it's generally best to use it at the end of an expression or wrap it
in parentheses when needed. 
```{r}
# Initialize the heatmap with color scales and annotations.
ggheatmap(small_mat) +
  scale_fill_viridis_c() +
  anno_left(size = 0.2) +
  # Add a dendrogram in the left annotation and split the dendrogram into 3 groups
  align_dendro(aes(color = branch), k = 3L) +
  anno_right(size = 0.2) +
  # Add a dendrogram in the right annotation and split the dendrogram into 3 groups
  align_dendro(aes(color = branch), k = 3L) &
  # Set color scale for all plots
  scale_color_brewer(palette = "Dark2")
```

## Subtraction operator
>`-`: Adds elements to all plots in the active layout, as well as to any nested
layouts within it (this behavior differs in `stack_layout()`; refer to
`vignette("stack-layout")` for more details).

Using `-` might seem unintuitive if you think of the operator as `"subtract"`,
the underlying reason is that `-` is the only operator in the same precedence
group as `+`, allowing for seamless combination with `+`.

If the active layout is the `ggheatmap()`/`quad_layout()`, `-` functions
similarly to `&`.
```{r}
# Initialize the heatmap with color scales and annotations.
my_plot <- ggheatmap(small_mat) +
  scale_fill_viridis_c() +
  anno_left(size = 0.2) +
  align_dendro(aes(color = branch), k = 3L) +
  anno_right(size = 0.2) +
  align_dendro(aes(color = branch), k = 3L) +
  # Remove any active annotation
  quad_active() -
  # Set color scale for all plots, since the active layout is the `ggheatmap()`/`quad_layout()`
  scale_color_brewer(palette = "Dark2") +
  # No need for parentheses; we can directly add other elements
  # Change the active layout to the top annotation
  anno_top(size = 0.2) +
  # Add a dendrogram in the top annotation
  align_dendro()
my_plot
```

If the active layout is not the `ggheatmap()`/`quad_layout()`, the `-` operator
will only add elements to all plots in the active annotation stack: 
```{r}
my_plot +
  # Change the active layout to the left annotation
  anno_left() -
  # Modify the background of all plots in the left annotation
  theme(plot.background = element_rect(fill = "red"))
```

### `with_position`
Along with the `-` operator, `with_position()` can be used to modify the
operated context in `ggheatmap()`/`quad_layout()`.

It accepts two arguments: the object operated on by the `-` operator and the
operated context. 

By default, if the current active context in `ggheatmap()`/`quad_layout()` is
`top` or `bottom`, the operator will also act on the corresponding `bottom` or
`top` annotation. If the context is `left` or `right`, the operator will also
act on the `right` or `left` annotation, respectively. If there is no active
annotation stack, it defaults to `NULL` (this behavior differs in
`stack_layout()`; refer to `vignette("stack-layout")` for more details).
```{r}
my_plot +
  # Change the active layout to the left annotation
  anno_left() -
  # Modify the background of all plots in the left and the opposite annotation
  with_position(theme(plot.background = element_rect(fill = "red")))
```

The second argument can be a string containing one or more of `r
ggalign:::oxford_and(ggalign:::.tlbr)`, indicating which annotation stack should
be used as the context. The above example is equivalent to: 
```{r}
my_plot -
  # Modify the background of all plots in the left and right annotation
  with_position(theme(plot.background = element_rect(fill = "red")), "lr")
```

If it is `NULL`, it removes any active annotation stack:
```{r}
my_plot -
  # Modify the background of all plots
  with_position(theme(plot.background = element_rect(fill = "red")), NULL)
```

### Plot options
Plot options control the action of plots in the layout. This package allows a
flexible way to set these options. While we'll dive deeper into plot options in
`vignette("plot-options")`, I wanted to introduce it here, as they rely heavily
on the `-` operator.

>Plot options inherit properties from parent layout options hierarchically.

All plot options can be set at the layout level to define global options, or
they can be applied to individual plots. Here, we'll take `plot_theme()` as a
example since it is just a enhanced `theme()` which sets the default theme for
the plot.

To set a plot option for a single plot, simply use the `+` operator:
```{r}
my_plot +
  # Change the active layout to the top annotation
  anno_top() +
  # change the default theme of the dendrogram in the top annotation
  plot_theme(plot.background = element_rect(fill = "red"))
```

Note that `plot_theme()` serves as the default theme and will always be
overridden by any `theme()` settings applied directly to the plot. The default
theme (`plot_theme()`) is applied first, followed by any specific `theme()`
settings, even if `theme()` is added before `plot_theme()`.
```{r}
my_plot +
  # Change the active layout to the top annotation
  anno_top() +
  # change the plot theme of the dendrogram in the top annotation
  theme(plot.background = element_rect(fill = "blue")) +
  # change the default theme of the dendrogram in the top annotation
  plot_theme(plot.background = element_rect(fill = "red"))
```

By using the `-` operator with plot options, we apply them directly to the
active layout. As mentioned earlier, the `-` operator applies specified elements
to all plots within the current layout, making it ideal for setting layout-level
plot options. Additionally, we can combine `with_position()` with the `-`
operator.
```{r}
my_plot +
  # Change the active layout to the top annotation
  anno_top() +
  ggalign(aes(.names, value, fill = factor(.names)), data = rowSums) +
  geom_bar(stat = "identity") -
  # Change the default theme of the top annotation
  # All plots in the top annotation will inherit this default theme
  plot_theme(plot.background = element_rect(fill = "red"))
```

# Session information
```{r}
sessionInfo()
```
